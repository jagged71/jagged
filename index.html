<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Conclave Arcana Memory Game - VS Portia</title>
<style>
  /* === Base Styles from your file with improvements === */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  html, body {
    width: 100%;
    overflow-x: hidden;
  }
  body {
    font-family: 'Arial', sans-serif;
    background: linear-gradient(135deg, #1a0033, #2d1b69, #4a148c);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    color: #fff;
    animation: backgroundShimmer 15s ease-in-out infinite;
  }
  @keyframes backgroundShimmer {
    0%, 100% { background: linear-gradient(135deg, #1a0033, #2d1b69, #4a148c); }
    50%     { background: linear-gradient(135deg, #2d1b69, #4a148c, #6a1b9a); }
  }
  .branding-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 900px;
    margin: 10px auto 30px auto;
    padding: 0 20px;
    box-sizing: border-box;
  }
  .logo {
    height: auto;
    max-height: 55px;
    max-width: 40%;
    object-fit: contain;
  }
  .header {
    text-align: center;
    margin-bottom: 30px;
  }
  .header h1 {
    font-size: clamp(1.8rem, 5vw, 2.5rem);
    background: linear-gradient(45deg, #ffd700, #ff6b35);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    animation: titlePulse 3s ease-in-out infinite;
  }
  @keyframes titlePulse {
    0%, 100% { transform: scale(1); }
    50%      { transform: scale(1.05); }
  }

  .intro-modal, .game-menu {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.95);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 11000;
  }

  .intro-modal {
    flex-direction: column;
    padding: 30px;
  }
  .intro-modal .modal-content, .game-menu .menu-content {
    max-width: 400px;
    background: #222;
    border-radius: 15px;
    padding: 30px 30px 40px;
    text-align: center;
    color: #fff;
    box-shadow: 0 0 50px #ff6b35cc;
    position: relative;
  }
  .intro-modal h2, .game-menu h2 {
    color: #ffd700;
    margin-bottom: 20px;
  }
  .intro-modal p {
    margin-bottom: 25px;
    font-size: 1.2rem;
  }
  .btn {
    background: linear-gradient(45deg, #ff6b35, #ffd700);
    color: #1a0033;
    border: none;
    padding: 14px 25px;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    margin-top: 10px;
    position: relative;
    overflow: hidden;
  }
  .btn:hover {
    box-shadow: 0 0 15px #ff6b35;
    transform: translateY(-3px);
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
    transition: left 0.5s;
    z-index: 2;
  }
  .btn:hover::before {
    left: 100%;
  }

  label {
    display: block;
    margin-bottom: 7px;
    font-weight: 600;
  }

  input[type="text"], select {
    width: 100%;
    padding: 10px 12px;
    border-radius: 8px;
    border: none;
    font-size: 1rem;
    background: rgba(255,255,255,0.15);
    color: #fff;
    box-shadow: inset 0 0 3px #000;
    transition: background 0.25s ease;
  }
  input[type="text"]:focus, select:focus {
    outline: none;
    background: rgba(255,215,0,0.3);
  }

  /* Game menu - appears after intro modal */
  .game-menu {
    background: rgba(26, 0, 51, 0.95);
    flex-direction: column;
    color: #fff;
  }
  .game-menu .menu-content {
    max-width: 420px;
    padding: 25px 30px 40px;
    box-shadow: 0 0 40px #ffd700aa;
  }
  .game-menu label {
    font-weight: 700;
    margin-top: 15px;
  }

  /* Game Info panel */
  .game-info {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: clamp(12px, 3vw, 24px);
    margin-bottom: 20px;
    font-size: clamp(1rem, 2.5vw, 1.2rem);
  }
  .game-info > div {
    background: rgba(255, 255, 255, 0.1);
    padding: 10px 20px;
    border-radius: 12px;
    backdrop-filter: blur(8px);
    border: 1.5px solid rgba(255,255,255,0.25);
    user-select: none;
    min-width: 120px;
    font-weight: 600;
  }
  .score.pc-score {
    color: #ffb700;
  }
  .turn-indicator {
    font-size: 1.3rem;
    font-weight: 900;
    text-align: center;
    color: #ffd700;
    margin-bottom: 20px;
    letter-spacing: 0.06em;
    text-shadow:
      0 0 5px #ffad00,
      0 0 15px #ffad00,
      0 0 25px #ffae00dd;
    animation: turnGlow 2.5s ease-in-out infinite;
  }
  @keyframes turnGlow {
    0%, 100% {
      text-shadow:
        0 0 5px #ffad00,
        0 0 15px #ffad00,
        0 0 25px #ffae00dd;
      color: #ffd700;
    }
    50% {
      text-shadow:
        0 0 15px #fff3ab,
        0 0 35px #fff3ab,
        0 0 55px #fff3abdd;
      color: #fff3ab;
    }
  }

  /* Cards container */
  .game-container {
    display: grid;
    gap: clamp(7px, 2vw, 15px);
    justify-content: center;
    max-width: 95vw;
    width: 100%;
    margin-bottom: 25px;
  }

  /* Grid for each difficulty */
  .game-container.easy {
    grid-template-columns: repeat(4, 1fr);
  }
  .game-container.medium {
    grid-template-columns: repeat(6, 1fr);
  }
  .game-container.hard {
    grid-template-columns: repeat(8, 1fr);
  }
  .game-container.crazy {
    grid-template-columns: repeat(12, 1fr);
  }

  /* Card styles */
  .card {
    position: relative;
    width: 100%;
    aspect-ratio: 3 / 4;
    max-width: 160px;
    max-height: 220px;
    cursor: pointer;
    perspective: 850px;
    box-shadow:
      0 5px 15px rgba(255, 107, 53, 0.15),
      0 2px 8px rgba(0,0,0,0.7);
    border-radius: 15px;
    overflow: hidden;
    user-select: none;
    transition: transform 0.2s ease;
  }
  .card:hover:not(.flipped):not(.matched) {
    transform: scale(1.05) rotateZ(3deg);
  }
  .card.matched {
    opacity: 0.5;
    cursor: default;
    animation: matchedBounce 0.8s ease forwards;
  }
  @keyframes matchedBounce {
    0% { transform: scale(1) rotateZ(0deg); }
    50% { transform: scale(1.15) rotateZ(7deg); }
    100% { transform: scale(0.9) rotateZ(0deg); }
  }
  .card.hint-glow {
    animation: hintGlow 2s ease-in-out;
    box-shadow: 0 0 16px 3px #ffd700cc;
  }
  @keyframes hintGlow {
    0%, 100% {
      box-shadow: 0 0 15px 3px #ffd700cc;
      transform: scale(1);
    }
    50% {
      box-shadow: 0 0 40px 10px #ffde00cc;
      transform: scale(1.07);
    }
  }
  .card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.6s;
    transform-style: preserve-3d;
    border-radius: 15px;
  }
  .card.flipped .card-inner {
    transform: rotateY(180deg);
  }
  .card-front, .card-back {
    position: absolute;
    border-radius: 15px;
    backface-visibility: hidden;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border: 3px solid #ffd700;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }
  .card-front {
    background: linear-gradient(135deg, #3a0a7c, #7737c3);
    color: #fff;
    padding: 5px;
    transform: rotateY(180deg);
  }
  .card-front img {
    width: 80%;
    border-radius: 15px;
    object-fit: contain;
  }
  .card-back {
    background: linear-gradient(135deg, #000, #fff);
    filter: grayscale(90%) brightness(80%);
    padding: 6px;
  }
  .card-logo {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
  }

  /* Controls */
  .controls {
    display: flex;
    gap: 15px;
    margin-top: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }

  /* Victory Modal */
  .victory-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(25,25,25, 0.95);
    color: #ffd700;
    padding: 30px 35px;
    border-radius: 20px;
    text-align: center;
    font-size: clamp(1rem, 3vw, 1.5rem);
    display: none;
    z-index: 10500;
    max-width: 90vw;
    width: 420px;
    box-shadow:
      0 0 20px 6px #ffab00dd,
      0 0 40px 13px #ffd700aa;
    animation: victoryPop 0.6s ease-out forwards;
  }
  @keyframes victoryPop {
    0%   { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }
  .victory-message h2 {
    font-size: 2.25rem;
    margin-bottom: 15px;
    text-shadow:
      0 0 10px #ffcc00dd,
      0 0 20px #ffcc00dd;
  }
  .victory-message p {
    margin-bottom: 20px;
  }
  .victory-message em {
    font-style: italic;
    font-weight: 700;
  }

  .victory-message button {
    margin-top: 15px;
  }

  /* Streak Indicator */
  .streak-indicator {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(255, 215, 0, 0.9);
    color: #1a0033;
    padding: 10px 15px;
    border-radius: 25px;
    font-weight: bold;
    transform: translateX(120px);
    opacity: 0;
    z-index: 1200;
    transition: transform 0.5s ease, opacity 0.5s ease;
    pointer-events: none;
  }
  .streak-indicator.show {
    transform: translateX(0);
    opacity: 1;
  }

  /* Audio controls with flex and spacing */
  .audio-controls {
    margin: 20px 0;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
    background: rgba(255, 255, 255, 0.08);
    padding: 15px 20px;
    border-radius: 12px;
    backdrop-filter: blur(10px);
  }

  .audio-controls button {
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    background: #ff6b35cc;
    color: white;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .audio-controls button:hover {
    background: #ff6b35;
    transform: translateY(-1px);
  }

  .audio-controls label {
    font-weight: 600;
    user-select: none;
  }

  .audio-controls input[type=range] {
    width: 110px;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    body {
      padding: 12px;
    }
    .game-container.easy { grid-template-columns: repeat(4, 1fr); }
    .game-container.medium { grid-template-columns: repeat(4, 1fr); }
    .game-container.hard { grid-template-columns: repeat(5, 1fr); }
    .game-container.crazy { grid-template-columns: repeat(6, 1fr); }
    .card {
      max-width: 120px;
      max-height: 180px;
    }
  }
  @media (max-width: 480px) {
    .game-container.easy { grid-template-columns: repeat(3, 1fr); }
    .game-container.medium { grid-template-columns: repeat(4, 1fr); }
    .game-container.hard { grid-template-columns: repeat(4, 1fr); }
    .game-container.crazy { grid-template-columns: repeat(5, 1fr); }
    .card {
      max-width: 90px;
      max-height: 135px;
    }
  }
</style>
</head>
<body>
<div class="header branding-inline">
  <img alt="Splinterlands" class="logo splinterlands-logo" src="splinterlands-logo.png"/>
  <h1>⚔️ Conclave Arcana Memory Game ⚔️</h1>
  <p>Match the character images!</p>
  <img alt="Conclave Arcana" class="logo conclave-logo" src="conclave-arcana-logo.png"/>
</div>

<footer class="footer-links">
  <p>
    <a href="https://splinterlands.com" target="_blank">🌐 Play Splinterlands</a> |
    <a href="https://discord.gg/pkuTQBVR" target="_blank">💬 Join Discord</a>
  </p>
</footer>

<!-- INTRODUCTORY MODAL MENU -->
<div class="intro-modal" id="introModal" role="dialog" aria-labelledby="introTitle" aria-modal="true" aria-describedby="introDesc">
  <div class="modal-content">
    <h2 id="introTitle">✨ Welcome to Conclave Arcana Memory Game</h2>
    <p id="introDesc">A Splinterlands Universe Game</p>
    <a class="btn" href="https://splinterlands.com" target="_blank" rel="noopener noreferrer">Visit Splinterlands</a>
    <button class="btn" id="enterGameBtn" aria-label="Enter Game">Enter Game</button>
  </div>
</div>

<!-- GAME MENU - select mode, name, difficulty -->
<div class="game-menu" id="gameMenu" role="region" aria-label="Game Settings" style="display:none;">
  <div class="menu-content">
    <h2>Game Settings</h2>
    <label for="playerName"><strong>Your Name:</strong></label>
    <input type="text" id="playerName" placeholder="Enter your name" autocomplete="off" />

    <label for="modeSelect"><strong>Game Mode:</strong></label>
    <select id="modeSelect" title="Select Game Mode">
      <option value="single" selected>Single Player</option>
      <option value="vsportia">VS Portia (PC)</option>
    </select>

    <label for="difficulty"><strong>Difficulty:</strong></label>
    <select id="difficulty">
      <option value="easy">Easy (16 cards)</option>
      <option value="medium">Medium (36 cards)</option>
      <option value="hard">Hard (64 cards)</option>
      <option value="crazy">Crazy (144 cards)</option>
    </select>

    <button class="btn" id="startGameBtn" aria-label="Start Game">Start Game</button>
  </div>
</div>

<!-- GAME INFO PANEL -->
<div class="game-info" style="display:none;" aria-live="polite" aria-atomic="true" aria-relevant="text">
  <div class="score">Player Score: <span id="score">0</span></div>
  <div class="score pc-score" style="display:none;">Portia's Score: <span id="pcScore">0</span></div>
  <div class="moves">Moves: <span id="moves">0</span></div>
  <div class="timer">Time: <span id="timer">00:00</span></div>
  <div class="hints-remaining">Hints: <span id="hintsRemaining">2</span></div>
</div>

<!-- TURN INDICATOR -->
<div class="turn-indicator" id="turnIndicator" style="display:none;" aria-live="assertive" aria-atomic="true" aria-relevant="text"></div>

<div class="streak-indicator" id="streakIndicator" role="alert" aria-atomic="true">
    🔥 Streak: <span id="streakCount">0</span>
</div>

<!-- GAME BOARD -->
<div class="game-container" id="gameContainer" aria-label="Memory Game Board" role="grid" tabindex="0" style="display:none;">
  <!-- Cards rendered here -->
</div>

<!-- CONTROLS -->
<div class="controls" style="display:none;">
  <button class="btn" id="newGameBtn" aria-label="New Game">New Game</button>
  <button class="btn" id="hintBtn" aria-label="Hint Button">Hint (Costs 10 pts)</button>
</div>

<!-- AUDIO CONTROLS -->
<div class="audio-controls" style="display:none;">
  <button id="muteBtn" aria-pressed="false" aria-label="Toggle Mute">Mute</button>
  <label for="musicVolume">Music Volume:</label>
  <input id="musicVolume" max="1" min="0" step="0.01" type="range" value="0.5" />
  <label for="sfxVolume">SFX Volume:</label>
  <input id="sfxVolume" max="1" min="0" step="0.01" type="range" value="1" />
</div>

<!-- VICTORY MESSAGE -->
<div class="victory-message" id="victoryMessage" role="alert" aria-live="assertive" aria-atomic="true">
  <h2>🎉 Victory! 🎉</h2>
  <p id="victoryText"></p>
  <button class="btn" id="playAgainBtn" aria-label="Play Again">Play Again</button>
</div>

<!-- HIGH SCORES -->
<div class="high-scores">
  <h2>🏆 High Scores 🏆</h2>
  <table id="highScoresTable" aria-label="High Scores Table">
    <thead>
      <tr>
        <th>Rank</th>
        <th>Name</th>
        <th>Score</th>
        <th>Difficulty</th>
        <th>Time</th>
      </tr>
    </thead>
    <tbody id="highScoresBody">
    </tbody>
  </table>
</div>

<script>
  // ===================== SOUNDS AND MUSIC =====================
  const music = {
    themes: [
      new Audio('sounds/Fire of Praetoria.mp3'),
      new Audio('sounds/The Talisman.mp3'),
      new Audio('sounds/War Begins.mp3')
    ],
    currentTheme: null,
    isPlaying: false,
    init() {
      this.themes.forEach(theme => {
        theme.loop = true;
        theme.volume = 0.5;
      });
    },
    playRandom() {
      if (this.currentTheme) {
        this.fadeOut(this.currentTheme, 1000, () => {
          this.currentTheme.pause();
          this.currentTheme.currentTime = 0;
        });
      }
      let availableThemes = this.themes.filter(t => t !== this.currentTheme);
      this.currentTheme = availableThemes[Math.floor(Math.random() * availableThemes.length)];
      this.currentTheme.currentTime = 0;
      this.currentTheme.volume = 0;
      this.currentTheme.play();
      this.fadeIn(this.currentTheme, 1500);
      this.isPlaying = true;
    },
    fadeOut(audio, duration, callback) {
      const fadeInterval = 50;
      const steps = duration / fadeInterval;
      const stepSize = audio.volume / steps;
      const fade = setInterval(() => {
        if (audio.volume > stepSize) {
          audio.volume -= stepSize;
        } else {
          audio.volume = 0;
          clearInterval(fade);
          if(callback) callback();
        }
      }, fadeInterval);
    },
    fadeIn(audio, duration) {
      const targetVolume = 0.5;
      const fadeInterval = 50;
      const steps = duration / fadeInterval;
      const stepSize = targetVolume / steps;
      audio.volume = 0;
      const fade = setInterval(() => {
        if (audio.volume < targetVolume - stepSize) {
          audio.volume += stepSize;
        } else {
          audio.volume = targetVolume;
          clearInterval(fade);
        }
      }, fadeInterval);
    },
    toggle() {
      if(this.isPlaying) {
        this.fadeOut(this.currentTheme, 800);
      } else {
        this.fadeIn(this.currentTheme, 800);
      }
      this.isPlaying = !this.isPlaying;
    }
  };

  const sounds = {
    flip: new Audio('sounds/flip.wav'),
    correct: new Audio('sounds/correct.wav'),
    fourinarow: new Audio('sounds/winnerwinner.mp3'),
    complete: new Audio('sounds/complete.mp3'),
    keeptrying: new Audio('sounds/keeptrying.mp3'),
    pickle: new Audio('sounds/extrapickles.wav'),
    ohno1: new Audio('sounds/ohno.mp3'),
    ohno2: new Audio('sounds/ohno2.wav'),
    threeinarow: new Audio('sounds/threeinarow.mp3'),
    twoinarow: new Audio('sounds/twoinarow.mp3'),
    unstoppable: new Audio('sounds/unstoppable.mp3'),
    victory: new Audio('sounds/victory.mp3'),
    extrapickup: new Audio('sounds/extrapickup.wav'),
    heartbeat: new Audio('sounds/heartbeat.mp3'),
    ohyeah: new Audio('sounds/ohyeah.wav'),
    nopressure: new Audio('sounds/nopressure.mp3'),
    areyoutrying: new Audio('sounds/areyoutrying.mp3')
  };
  Object.values(sounds).forEach(snd => snd.volume = 0.5);
  music.init();

  const muteBtn = document.getElementById('muteBtn');
  const musicVolumeSlider = document.getElementById('musicVolume');
  const sfxVolumeSlider = document.getElementById('sfxVolume');
  let isMuted = false;

  muteBtn.addEventListener('click', () => {
    isMuted = !isMuted;
    if(isMuted) {
      updateMusicVolume(0);
      updateSFXVolume(0);
      muteBtn.textContent = 'Unmute';
      muteBtn.setAttribute('aria-pressed','true');
    } else {
      updateMusicVolume(parseFloat(musicVolumeSlider.value));
      updateSFXVolume(parseFloat(sfxVolumeSlider.value));
      muteBtn.textContent = 'Mute';
      muteBtn.setAttribute('aria-pressed','false');
    }
  });
  musicVolumeSlider.addEventListener('input', e => {
    if(!isMuted) updateMusicVolume(parseFloat(e.target.value));
  });
  sfxVolumeSlider.addEventListener('input', e => {
    if(!isMuted) updateSFXVolume(parseFloat(e.target.value));
  });

  function updateMusicVolume(vol) {
    music.themes.forEach(t => t.volume = vol);
  }
  function updateSFXVolume(vol) {
    Object.values(sounds).forEach(snd => snd.volume = vol);
  }

  function startMusicOnFirstInteraction() {
    function playOnce() {
      music.playRandom();
      window.removeEventListener('click', playOnce);
      window.removeEventListener('keydown', playOnce);
      window.removeEventListener('touchstart', playOnce);
    }
    window.addEventListener('click', playOnce);
    window.addEventListener('keydown', playOnce);
    window.addEventListener('touchstart', playOnce);
  }
  startMusicOnFirstInteraction();

  // ==================== GAME STATE AND LOGIC ====================

  // List of characters as in your file
  const conclaveCharacters = [
    { name: "Janni Oracle", image: "Janni Oracle.png" },
    { name: "Jicarilla the Rime", image: "Jicarilla the Rime.png" },
    { name: "Kavor Skarn", image: "Kavor Skarn.png" },
    { name: "Kaylia Silverleaf", image: "Kaylia Silverleaf.png" },
    { name: "Leolin Sifu", image: "Leolin Sifu.png" },
    { name: "Lucky Longshot", image: "Lucky Longshot.png" },
    { name: "Mad Kaboomist", image: "Mad Kaboomist.png" },
    { name: "Mahkah Hemlig", image: "Mahkah Hemlig.png" },
    { name: "Molten Elemental", image: "Molten Elemental.png" },
    { name: "Moribund Arrowbait", image: "Moribund Arrowbait.png" },
    { name: "Mystic Mudbinder", image: "Mystic Mudbinder.png" },
    { name: "Oridum Graybrow", image: "Oridum Graybrow.png" },
    { name: "Owlkin Geodesist", image: "Owlkin Geodesist.png" },
    { name: "Palifala Weslinath", image: "Palifala Weslinath.png" },
    { name: "Phlegmunculus", image: "Phlegmunculus.png" },
    { name: "Portly Cannoneer", image: "Portly Cannoneer.png" },
    { name: "Quillstorm Mage", image: "Quillstorm Mage.png" },
    { name: "Razi Clanktrap", image: "Razi Clanktrap.png" },
    { name: "Runic Skychonk", image: "Runic Skychonk.png" },
    { name: "Sacrosanct Shanker", image: "Sacrosanct Shanker.png" },
    { name: "Shadowfey Sheik", image: "Shadowfey Sheik.png" },
    { name: "Sheng Xiao", image: "Sheng Xiao.png" },
    { name: "Silverleaf Mage", image: "Silverleaf Mage.png" },
    { name: "Silverleaf Ranger", image: "Silverleaf Ranger.png" },
    { name: "Silverleaf Warlock", image: "Silverleaf Warlock.png" },
    { name: "Songale", image: "Songale.png" },
    { name: "Stampeding Calf", image: "Stampeding Calf.png" },
    { name: "Steppe Stalker", image: "Steppe Stalker.png" },
    { name: "Swiftbeard Stout", image: "Swiftbeard Stout.png" },
    { name: "Sylvaran Sentinel", image: "Sylvaran Sentinel.png" },
    { name: "Taye Loreswift", image: "Taye Loreswift.png" },
    { name: "Thragha", image: "Thragha.png" },
    { name: "Thraghun", image: "Thraghun.png" },
    { name: "Thunderous Herald", image: "Thunderous Herald.png" },
    { name: "Tidal Tsunamist", image: "Tidal Tsunamist.png" },
    { name: "Umbral Elemental", image: "Umbral Elemental.png" },
    { name: "Vicious Giraffe", image: "Vicious Giraffe.png" },
    { name: "Virid Venomancer", image: "Virid Venomancer.png" },
    { name: "Warwall Juggernaut", image: "Warwall Juggernaut.png" },
    { name: "Water Diviner", image: "Water Diviner.png" },
    { name: "Yaba's Pickle", image: "Yaba_s Pickle.png" },
    { name: "Zargrul", image: "Zargrul.png" },
    { name: "Abyssal Elemental", image: "Abyssal Elemental.png" },
    { name: "Aerial Shieldmaiden", image: "Aerial Shieldmaiden.png" },
    { name: "Anyu Huntswoman", image: "Anyu Huntswoman.png" },
    { name: "Aranduriel", image: "Aranduriel.png" },
    { name: "Arcane Skinwalker", image: "Arcane Skinwalker.png" },
    { name: "Archer Koi", image: "Archer Koi.png" },
    { name: "Archmage Yabanius", image: "Archmage Yabanius.png" },
    { name: "Ashen Cindergrim", image: "Ashen Cindergrim.png" },
    { name: "Auororal Elemental", image: "Auororal Elemental.png" },
    { name: "Bella Ratajowlski", image: "Bella Ratajowlski.png" },
    { name: "Bellowmancer", image: "Bellowmancer.png" },
    { name: "Blazebeard Merc", image: "Blazebeard Merc.png" },
    { name: "Bludgeon Hucker", image: "Bludgeon Hucker.png" },
    { name: "Boring Hobgoblin", image: "Boring Hobgoblin.png" },
    { name: "Bren Palesworn", image: "Bren Palesworn.png" },
    { name: "Bristleborn Brigand", image: "Bristleborn Brigand.png" },
    { name: "Buttercup Mauler", image: "Buttercup Mauler.png" },
    { name: "Calabash Sage", image: "Calabash Sage.png" },
    { name: "Canary Keeper", image: "Canary Keeper.png" },
    { name: "Caravan Guard", image: "Caravan Guard.png" },
    { name: "Cavewise Wayfinder", image: "Cavewise Wayfinder.png" },
    { name: "Conclave Artificer", image: "Conclave Artificer.png" },
    { name: "Conclave Tracker", image: "Conclave Tracker.png" },
    { name: "Craniax the Quick", image: "Craniax the Quick.png" },
    { name: "Decrepit Windseer", image: "Decrepit Windseer.png" },
    { name: "Deep Delver", image: "Deep Delver.png" },
    { name: "Desolation", image: "Desolation.png" },
    { name: "Fenmoor Gorgon", image: "Fenmoor Gorgon.png" },
    { name: "Fenmoor Platypus", image: "Fenmoor Platypus.png" },
    { name: "Fenmoor Wood Troll", image: "Fenmoor Wood Troll.png" },
    { name: "Ferrous Brewer", image: "Ferrous Brewer.png" },
    { name: "Filthy Scavenger", image: "Filthy Scavenger.png" },
    { name: "Fithe Bladestone", image: "Fithe Bladestone.png" },
    { name: "Flame for Hire", image: "Flame for Hire.png" },
    { name: "Folen Flameye", image: "Folen Flameye.png" },
    { name: "Forked-Tongue Sage", image: "Forked-Tongue Sage.png" },
    { name: "Gonach Excavator", image: "Gonach Excavator.png" },
    { name: "Gorgug the Endless", image: "Gorgug the Endless.png" },
    { name: "Gramel the Hunger", image: "Gramel the Hunger.png" },
    { name: "Grimward Ruinshot", image: "Grimward Ruinshot.png" },
    { name: "Halfshell Seer", image: "Halfshell Seer.png" },
    { name: "Happy Quokka", image: "Happy Quokka.png" },
    { name: "Hodlor", image: "Hodlor.png" },
    { name: "Inept Healer", image: "Inept Healer.png" }
  ];

  // Difficulty config
  const difficulties = {
    easy: { pairs: 8, grid: 4 },
    medium: { pairs: 18, grid: 6 },
    hard: { pairs: 32, grid: 8 },
    crazy: { pairs: 72, grid: 12 }
  };

  // UI references
  const introModal = document.getElementById('introModal');
  const gameMenu = document.getElementById('gameMenu');
  const startGameBtn = document.getElementById('startGameBtn');
  const enterGameBtn = document.getElementById('enterGameBtn');
  const newGameBtn = document.getElementById('newGameBtn');

  // State variables
  let isVsPcMode = false;
  let pcScore = 0;
  let playerScore = 0;
  let currentTurn = 'player';
  let flippedCards = [];
  let matchedPairs = 0;
  let hintsRemaining = 2;
  let moves = 0;
  let timer = 0;
  let timerInterval = null;
  let pcMemory = new Map();
  let cards = [];

  // Helper shuffle
  function shuffle(arr) {
    let a = arr.slice();
    for (let i = a.length -1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Screen Switching Functions

  function showIntro() {
    introModal.style.display = 'flex';
    gameMenu.style.display = 'none';
    gameContainer.style.display = 'none';
    document.querySelector('.game-info').style.display = 'none';
    document.querySelector('.controls').style.display = 'none';
    document.querySelector('.audio-controls').style.display = 'none';
    document.getElementById('turnIndicator').style.display = 'none';
    document.getElementById('streakIndicator').style.display = 'none';
    victoryMessage.style.display = 'none';
  }

  function showGameMenu() {
    introModal.style.display = 'none';
    gameMenu.style.display = 'block';
  }

  function showGameUI() {
    gameMenu.style.display = 'none';
    gameContainer.style.display = 'grid';
    document.querySelector('.game-info').style.display = 'flex';
    document.querySelector('.controls').style.display = 'flex';
    document.querySelector('.audio-controls').style.display = 'flex';
    document.getElementById('streakIndicator').style.display = 'block';
  }

  // Event on intro btn
  enterGameBtn.addEventListener('click', () => {
    showGameMenu();
  });

  // Start button event
  startGameBtn.addEventListener('click', () => {
    vsPcModeToggle();
    vsPcGameInit();
    showGameUI();
  });

  newGameBtn.addEventListener('click', () => {
    vsPcGameInit();
  });

  // Toggle VS PC mode from menu select
  function vsPcModeToggle() {
    const modeValue = document.getElementById('modeSelect').value;
    isVsPcMode = modeValue === 'vsportia';

    // Show/hide Portia score and turn indicator accordingly
    document.querySelector('.score.pc-score').style.display = isVsPcMode ? 'block' : 'none';

    if (isVsPcMode) {
      document.getElementById('turnIndicator').style.display = 'block';
      document.getElementById('turnIndicator').textContent = 'Your turn';
    } else {
      document.getElementById('turnIndicator').style.display = 'none';
    }
  }

  // Initialize or restart the game
  function vsPcGameInit() {
    hintsRemaining = 2;
    moves = 0;
    timer = 0;
    playerScore = 0;
    pcScore = 0;
    matchedPairs = 0;
    flippedCards = [];
    pcMemory.clear();
    currentTurn = 'player';

    updateGameStats();
    clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      timer++;
      updateTimer();
    }, 1000);

    modeSelect.value = isVsPcMode ? 'vsportia' : 'single';
    difficultySelect.value = difficultySelect.value || 'medium';

    // Generate cards array
    const pairCount = difficulties[difficultySelect.value].pairs;

    // Shuffle characters and slice for pairs
    let shuffledChars = shuffle(conclaveCharacters).slice(0, pairCount);

    // Create pairs: image card + name card with matchId linking them
    cards = [];

    shuffledChars.forEach((char, i) => {
      cards.push(
        { id: `img_${i}`, type: 'image', character: char, matchId: i },
        { id: `name_${i}`, type: 'name', character: char, matchId: i }
      );
    });

    cards = shuffle(cards);

    renderCards();

    updateGameStats();

    if (isVsPcMode) {
      setTurnIndicator(currentTurn);
      if (currentTurn === 'pc') {
        pcTurn();
      }
    } else {
      document.getElementById('turnIndicator').style.display = 'none';
    }
  }

  // Render cards to board grid
  function renderCards() {
    gameContainer.innerHTML = '';
    // Add grid class for layout according to difficulty
    gameContainer.className = `game-container ${difficultySelect.value}`;

    cards.forEach((card, i) => {
      const cardElement = document.createElement('div');
      cardElement.className = 'card';
      cardElement.dataset.index = i;
      cardElement.setAttribute('tabindex', '0');
      cardElement.setAttribute('aria-label', 'Face down card');
      cardElement.setAttribute('role', 'button');
      cardElement.onclick = () => onCardClick(i);
      cardElement.onkeydown = (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onCardClick(i);
        }
      };
      cardElement.innerHTML = `
        <div class="card-inner">
          <div class="card-front">
            <img src="${card.character.image}" alt="${card.character.name}" class="card-image" />
          </div>
          <div class="card-back">
            <img src="conclave-arcana-logo.png" alt="Conclave Arcana Logo" class="card-logo" />
          </div>
        </div>
      `;
      gameContainer.appendChild(cardElement);
    });
  }

  // Card click logic (for both modes)
  let isLocked = false; // Prevent input during animations
  function onCardClick(index) {
    if (isLocked) return;

    const cardElement = gameContainer.querySelector(`.card[data-index="${index}"]`);
    if (!cardElement) return;
    if (cardElement.classList.contains('flipped') || cardElement.classList.contains('matched')) return;
    if (flippedCards.length >= 2) return;
    if (isVsPcMode && currentTurn !== 'player') return;

    flipCardVisual(cardElement);
    sounds.flip.play();

    flippedCards.push({ index, card: cards[index], element: cardElement });

    if (isVsPcMode) {
      // PC remembers player's flips
      pcRemember(flippedCards[flippedCards.length -1].index, flippedCards[flippedCards.length -1].card);
    }

    if (flippedCards.length === 2) {
      isLocked = true;
      moves++;
      updateMoves();
      setTimeout(checkMatch, 1000);
    }
  }

  // Flip card visually
  function flipCardVisual(cardElement) {
    cardElement.classList.add('flipped');
    cardElement.setAttribute('aria-label', 'Card face up');
  }
  // Unflip card visually
  function unflipCardVisual(cardElement) {
    cardElement.classList.remove('flipped');
    cardElement.setAttribute('aria-label', 'Card face down');
  }

  // Check match for flipped cards - the core logic depends on mode
  async function checkMatch() {
    const [first, second] = flippedCards;
    if (!first || !second) {
      isLocked = false;
      return;
    }
    const match = first.card.matchId === second.card.matchId;

    if (match) {
      // Cards matched
      first.element.classList.add('matched');
      second.element.classList.add('matched');
      sounds.correct.play();

      if (isVsPcMode && currentTurn === 'player') {
        playerScore++;
        pcForget(first.index, first.card.matchId);
        pcForget(second.index, second.card.matchId);
        matchedPairs++;
        updateScores();
        updateStreak(1);

        updateHintsIfNeeded();

        flippedCards = [];
        isLocked = false;

        if (matchedPairs === difficulties[difficultySelect.value].pairs) {
          gameWon('player');
          return;
        }
        // Player keeps turn
        setTurnIndicator('player');

      } else if (!isVsPcMode) {
        // Single Player scoring
        vsSinglePlayerScoreMatch();
      }
    } else {
      // Cards did not match
      if (isVsPcMode) {
        // Penalty for player mismatch
        if(currentTurn === 'player') {
          playerScore = Math.max(0, playerScore - 10);
          updateScores();
          updateStreak(0);
        }

        setTimeout(() => {
          unflipCardVisual(first.element);
          unflipCardVisual(second.element);
          flippedCards = [];
          isLocked = false;

          if (currentTurn === 'player') {
            currentTurn = 'pc';
            setTurnIndicator('pc');
            pcTurn();
          }
        }, 1200);

        if(Math.random() < 0.3){
          const sfx = [
            sounds.keeptrying,
            sounds.ohno1,
            sounds.ohno2,
            sounds.heartbeat,
            sounds.ohyeah,
            sounds.nopressure,
            sounds.areyoutrying
          ];
          sfx[Math.floor(Math.random()*sfx.length)].play();
        }
      } else {
        // Single Player mismatch scoring
        vsSinglePlayerScoreMismatch();
      }
    }
  }

  // ============== PC (Portia) Logic ==============

  // PC remembers card flipped by player or self
  function pcRemember(index, card) {
    if (gameContainer.querySelector(`.card[data-index="${index}"]`).classList.contains('matched')) return;
    const matchId = card.matchId;
    if (!pcMemory.has(matchId)) pcMemory.set(matchId, []);
    const slots = pcMemory.get(matchId);
    if (!slots.includes(index)) slots.push(index);
  }
  // PC forgets matched cards
  function pcForget(index, matchId) {
    if(!pcMemory.has(matchId)) return;
    const slots = pcMemory.get(matchId);
    const pos = slots.indexOf(index);
    if(pos > -1) slots.splice(pos,1);
    if(slots.length === 0) pcMemory.delete(matchId);
  }

  // PC turn async handler
  async function pcTurn() {
    isLocked = true;
    while(currentTurn === 'pc' && matchedPairs < difficulties[difficultySelect.value].pairs) {
      // Check memory for known pair
      const pair = pcFindKnownPair() || pcPickRandomPair();

      if (!pair) break; // No cards to flip - unlikely

      // Flip first card
      flipCardVisual(gameContainer.querySelector(`.card[data-index="${pair[0]}"]`));
      pcRemember(pair[0], cards[pair[0]]);
      sounds.flip.play();
      await delay(700);
      // Flip second card
      flipCardVisual(gameContainer.querySelector(`.card[data-index="${pair[1]}"]`));
      pcRemember(pair[1], cards[pair[1]]);
      sounds.flip.play();
      await delay(700);

      if(cards[pair[0]].matchId === cards[pair[1]].matchId) {
        // PC matched!
        pcScore++;
        matchedPairs++;
        updateScores();
        pcForget(pair[0], cards[pair[0]].matchId);
        pcForget(pair[1], cards[pair[1]].matchId);

        gameContainer.querySelector(`.card[data-index="${pair[0]}"]`).classList.add('matched');
        gameContainer.querySelector(`.card[data-index="${pair[1]}"]`).classList.add('matched');

        sounds.correct.play();

        if(matchedPairs === difficulties[difficultySelect.value].pairs) {
          gameWon('pc');
          return;
        }
        await delay(1000);
      } else {
        // PC failed match - flip both back
        await delay(1200);
        unflipCardVisual(gameContainer.querySelector(`.card[data-index="${pair[0]}"]`));
        unflipCardVisual(gameContainer.querySelector(`.card[data-index="${pair[1]}"]`));
        sounds.keeptrying.play();
        currentTurn = 'player';
        setTurnIndicator(currentTurn);
        isLocked = false;
        return;
      }
    }
    // After everything, fallback turn to player
    currentTurn = 'player';
    setTurnIndicator(currentTurn);
    isLocked = false;
  }

  // PC find known pair from memory
  function pcFindKnownPair() {
    for (const [matchId, indices] of pcMemory.entries()) {
      if(indices.length >= 2){
        const unmatched = indices.filter(i => !gameContainer.querySelector(`.card[data-index="${i}"]`).classList.contains('matched'));
        if(unmatched.length >= 2){
          return [unmatched[0], unmatched[1]];
        }
      }
    }
    return null;
  }

  // PC pick two random unmatched cards
  function pcPickRandomPair() {
    const unmatched = [];
    gameContainer.querySelectorAll('.card').forEach(c => {
      if(!c.classList.contains('matched') && !c.classList.contains('flipped'))
        unmatched.push(parseInt(c.dataset.index));
    });
    if(unmatched.length <2) return null;
    const shuffled = shuffle(unmatched);
    return [shuffled[0], shuffled[1]];
  }

  // Update UI stats displays
  function updateScores() {
    document.getElementById('score').textContent = playerScore;
    document.getElementById('pcScore').textContent = pcScore;
  }
  function updateMoves() {
    movesElement.textContent = moves;
  }
  function updateHints() {
    hintsRemainingElement.textContent = hintsRemaining;
  }
  function updateTimer() {
    const mm = Math.floor(timer/60);
    const ss = timer%60;
    timerElement.textContent = `${mm.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')}`;
  }

  // Turn Indicator text update
  function setTurnIndicator(turn) {
    if(!isVsPcMode) {
      document.getElementById('turnIndicator').style.display = 'none';
      return;
    }
    document.getElementById('turnIndicator').style.display = 'block';
    if(turn === 'player') {
      document.getElementById('turnIndicator').textContent = "Your turn";
    } else if(turn === 'pc') {
      document.getElementById('turnIndicator').textContent = "Portia's turn";
    } else {
      document.getElementById('turnIndicator').textContent = "";
    }
  }

  // When hints are earned every 5 pairs matched
  function updateHintsIfNeeded() {
    if(matchedPairs % 5 === 0 && matchedPairs > 0) {
      hintsRemaining++;
      updateHints();
      sounds.extrapickup.play();
      showBonusNotification(`✨ Bonus Hint Earned! (${hintsRemaining} total)`);
    }
  }

  // Show streak near top right corner
  function showBonusNotification(msg) {
    const el = streakIndicator;
    el.textContent = msg;
    el.classList.add('show');
    clearTimeout(el.hideTimeout);
    el.hideTimeout = setTimeout(() => {
      el.classList.remove('show');
    }, 2500);
  }

  const victoryMessage = document.getElementById('victoryMessage');
  const victoryText = document.getElementById('victoryText');
  const playAgainBtn = document.getElementById('playAgainBtn');

  // Sarcastic lines for Portia
  const portiaLinesWin = [
    "Hah! Easy game. Challenge me again if you dare!",
    "Portia dominates once more! Better luck next time.",
    "You really thought you could beat me? Cute.",
    "Another win for Portia! Feel free to try again when ready."
  ];

  const portiaLinesLose = [
    "No... That can't be! Rematch me and I'll crush you!",
    "You got lucky... Try again to prove it wasn't a fluke.",
    "Portia's ego bruised, but not broken. Challenge me again!",
    "I let you win... Just this once. Ready for a real challenge?"
  ];

  function gameWon(winner) {
    clearInterval(timerInterval);
    isLocked = true;

    let msg = '';
    if (winner === 'player') {
      msg = `<p>You beat Portia!</p>
      <p>Moves: ${moves}</p>
      <p>Time: ${Math.floor(timer/60)}:${(timer%60).toString().padStart(2,'0')}</p>
      <p>Final Score: ${playerScore}</p><br/>
      <em>${portiaLinesLose[Math.floor(Math.random() * portiaLinesLose.length)]}</em>`;
      sounds.victory.play();
    } else {
      msg = `<p>Portia wins!</p>
      <p>Moves: ${moves}</p>
      <p>Time: ${Math.floor(timer/60)}:${(timer%60).toString().padStart(2,'0')}</p>
      <p>Final Score: ${pcScore}</p><br/>
      <em>${portiaLinesWin[Math.floor(Math.random() * portiaLinesWin.length)]}</em>`;
      sounds.victory.play();
    }

    victoryText.innerHTML = msg;
    victoryMessage.style.display = 'block';

    // Save player highscore only if player won
    if(winner === 'player') saveHighScore();
  }

  playAgainBtn.addEventListener('click', () => {
    victoryMessage.style.display = 'none';
    vsPcGameInit();
  });

  // Hint Button logic
  const hintBtnElement = document.getElementById('hintBtn');
  hintBtnElement.addEventListener('click', () => {
    if(hintsRemaining <= 0) {
      alert("You're out of hints!");
      return;
    }
    if(!isVsPcMode) {
      alert("Flip one card first to get a hint for its match!");
      return;
    }
    if(currentTurn !== 'player') {
      alert("Wait for your turn to get a hint.");
      return;
    }
    if(flippedCards.length !== 1) {
      alert("Flip one card first to get a hint for its match!");
      return;
    }
    const flippedCard = flippedCards[0];
    const matchId = flippedCard.card.matchId;
    let revealIdx = null;
    for(let i=0; i<cards.length; i++) {
      if(cards[i].matchId === matchId && i !== flippedCard.index) {
        const el = gameContainer.querySelector(`.card[data-index="${i}"]`);
        if(el && !el.classList.contains('matched')) {
          revealIdx = i;
          break;
        }
      }
    }
    if(revealIdx === null) {
      alert("No matching card found. Flip another card!");
      return;
    }
    hintsRemaining--;
    updateHints();
    sounds.pickle.play();
    const matchingElement = gameContainer.querySelector(`.card[data-index="${revealIdx}"]`);
    matchingElement.classList.add('hint-glow');
    setTimeout(() => {
      matchingElement.classList.remove('hint-glow');
    }, 1800);
  });



  // Helper: Save high scores to localStorage
  function saveHighScore() {
    const name = document.getElementById('playerName').value || 'Anonymous';
    const hsKey = 'conclaveArcanaHighScores';
    const highScores = JSON.parse(localStorage.getItem(hsKey) || "[]");
    highScores.push({
      name,
      score: playerScore,
      difficulty: difficultySelect.value,
      time: timer,
      date: (new Date()).toISOString()
    });
    highScores.sort((a,b) => b.score - a.score);
    if(highScores.length > 10) highScores.length = 10;
    localStorage.setItem(hsKey, JSON.stringify(highScores));
    loadHighScores();
  }

  // Load and display high scores
  function loadHighScores() {
    const hsKey = 'conclaveArcanaHighScores';
    const highScores = JSON.parse(localStorage.getItem(hsKey) || "[]");
    const tbody = document.getElementById('highScoresBody');
    tbody.innerHTML = '';
    highScores.forEach((entry, i) => {
      const tr = document.createElement('tr');
      const mm = Math.floor(entry.time/60);
      const ss = entry.time%60;
      const timeStr = `${mm.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')}`;
      tr.innerHTML = `<td>${i+1}</td><td>${entry.name}</td><td>${entry.score}</td><td>${capitalize(entry.difficulty)}</td><td>${timeStr}</td>`;
      tbody.appendChild(tr);
    });
  }

  function capitalize(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
  }

  // Delay helper
  function delay(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  // Initial display
  showIntro();
  loadHighScores();

</script>

<script>
  // Your existing intro splash code for session storage
  function closeIntroModal() {
    document.getElementById("introModal").style.display = "none";
  }

  window.addEventListener('load', () => {
    if(!sessionStorage.getItem('introSeen')) {
      document.getElementById("introModal").style.display = "flex";
      sessionStorage.setItem('introSeen', 'true');
    } else {
      document.getElementById("introModal").style.display = "none";
    }
  });
</script>

</body>
</html>
